<!--
Copyright (c) 2018 NVIDIA Corporation 
Author: Bryce Adelstein Lelbach <brycelelbach@gmail.com>

Distributed under the Boost Software License v1.0 (boost.org/LICENSE_1_0.txt)
-->
<pre class='metadata'>
Title: The C++20 Synchronization Library
Shortname: D1135
Revision: 2
Status: D
Group: WG21
Audience: LWG, LEWG, SG1
Editor: Bryce Adelstein Lelbach, NVIDIA, brycelelbach@gmail.com
Editor: Olivier Giroux, NVIDIA, ogiroux@nvidia.com
Editor: JF Bastien, Apple, jfbastien@apple.com
Editor: Detlef Vollmann, dv@vollmann.ch
URL: https://wg21.link/P1135R1
!Source: <a href="https://github.com/brycelelbach/wg21_p1135_cpp20_synchronization_library/blob/master/cpp20_synchronization_library.bs">GitHub</a>
Issue Tracking: GitHub https://github.com/brycelelbach/wg21_p1135_cpp20_synchronization_library/issues
Metadata Order: Author, This Version, Source, Issue Tracking, Project, Audience
Markup Shorthands: markdown yes
Toggle Diffs: no
No Abstract: yes
Boilerplate: style-syntax-highlighting off
</pre>

<style>
pre {
  margin-top: 0px;
  margin-bottom: 0px;
}
.ins, ins, ins *, span.ins, span.ins * {
  background-color: rgb(200, 250, 200);
  color: rgb(0, 136, 0);
  text-decoration: none;
}
.del, del, del *, span.del, span.del * {
  background-color: rgb(250, 200, 200);
  color: rgb(255, 0, 0);
  text-decoration: line-through;
  text-decoration-color: rgb(255, 0, 0);
}
math, span.math {
  font-family: serif;
  font-style: italic;
}
ul {
  list-style-type: "— ";
}
blockquote {
  counter-reset: paragraph;
}
div.numbered, div.newnumbered {
  margin-left: 2em;
  margin-top: 1em;
  margin-bottom: 1em;
}
div.numbered:before, div.newnumbered:before {
  position: absolute;
  margin-left: -2em;
  display-style: block;
}
div.numbered:before {
  content: counter(paragraph);
  counter-increment: paragraph;
}
div.newnumbered:before {
  content: "�";
}
div.numbered ul, div.newnumbered ul {
  counter-reset: list_item;
}
div.numbered li, div.newnumbered li {
  margin-left: 3em;
}
div.numbered li:before, div.newnumbered li:before {
  position: absolute;
  margin-left: -4.8em;
  display-style: block;
}
div.numbered li:before {
  content: "(" counter(paragraph) "." counter(list_item) ")";
  counter-increment: list_item;
}
div.newnumbered li:before {
  content: "(�." counter(list_item) ")";
  counter-increment: list_item;
}
</style>

# Introduction # {#intro}

This paper is the unification of the wording for a series of related C++20
proposals for introducing new synchronization and thread coordination
facilities and enhancing existing ones:

  - [[P0514r4]]: Efficient `atomic` waiting and semaphores.
  - [[P0666r2]]: Latches and barriers.
  - [[P0995r1]]: `atomic_flag::test` and lockfree integral types.
  - [[P1258r0]]: Don't make C++ unimplementable for small CPUs.

## Changelog ## {#changelog}

**Revision 0:** Post Rapperswil changes from [[P0514r4]], [[P0666r2]], and [[P0995r1]] based on <a href="http://wiki.edg.com/bin/view/Wg21rapperswil2018/P0666">Rapperswil feedback</a>.

  - Refactored `basic_barrier` and `barrier` into one class with a default template parameter as suggested by LEWG at Rapperswil.
  - Refactored `basic_semaphore` and `counting_semaphore` into one class with a default template parameter as suggested by LEWG at Rapperswil.
  - Fixed `update` parameters in semaphore, latch, and barrier member functions to consistently default to 1 to resolve mistakes identified by LEWG at Rapperswil.

**Revision 1:** Pre San Diego 2018 changes based on <a href="http://wiki.edg.com/bin/view/Wg21rapperswil2018/P0666">Rapperswil feedback</a> and <a href="http://lists.isocpp.org/lib-ext/2018/06/7755.php">a June discussion on the LEWG and SG1 mailing lists</a>.

  - Added member function versions of `atomic_wait_*` and `atomic_notify_*`, for consistency. Refactored wording to accommodate this.
  - Renamed the `atomic_flag` overloads of `atomic_wait` and `atomic_wait_explicit` to `atomic_flag_wait` and `atomic_flag_wait_explicit` for consistency and to leave the door open for future compatibility with C.
  - Renamed `latch::arrive_and_wait` and `barrier::arrive_and_wait` to `latch::sync` and `barrier::sync`, because LEWG at Rapperswil expected these methods to be the common use case and prefers they have a short name.
  - Renamed `latch::arrive` to `latch::count_down` to further separate and distinguish the `latch` and `barrier` interfaces.
  - Removed `barrier::try_wait` to resolve concerns raised during LEWG discussion at Rapperswil regarding its "maybe consuming" nature.
  - Required that `barrier::arrival_token`'s move constructor and move assignment operators are `noexcept` to resolve discussions in LEWG at Rapperswil regarding exceptions being thrown when using the split arrive and wait barrier interface. 
  - Clarified that `counting_semaphore::release`, `latch::count_down`, `latch::sync`, `barrier::wait`, and `barrier::arrive_and_drop` throw nothing (but cannot be `noexcept`, because they have preconditions) to resolve discussions in LEWG at Rapperswil and on the mailing list.  
  - Made `counting_semaphore::acquire`, `counting_semaphore::try_acquire`, and `latch::wait` `noexcept`, because participants in the mailing list discussion preferred that synchronization operations not throw and that any resource acquisition failures be reported by throwing during construction of synchronization objects.
  - Made `counting_semaphore`, `latch`, and `barrier`'s constructors non `constexpr` and allowed them to throw `system_error` if the latch cannot be created, because participants in the mailing list discussion preferred that synchronization operations not throw and that any resource acquisition failures be reported by throwing during construction of synchronization objects.

**Revision 2:** San Diego 2018 changes to incorporate [[P1258r0]] and pre-meeting feedback.

  - Made `barrier::wait` take its `arrival_token` parameter by rvalue reference.
  - Made the `atomic_signed_lock_free` and `atomic_unsigned_lock_free` types optional for freestanding implementations, as per [[P1258r0]].

# Wording # {#wording}

Note: The following changes are relative to the post-Rapperswil 2018 working draft of ISO/IEC 14882, 
([[N4762]]).

Note: The � character is used to denote a placeholder number which shall be selected by the editor.

Add `<semaphore>`, `<latch>`, and `<barrier>` to Table 18 "C++ library headers" in <a href="http://eel.is/c++draft/headers">[**headers**]</a>.

Modify the header synopsis for `<atomic>` in <a href="http://eel.is/c++draft/atomics.syn">[**atomics.syn**]</a> as follows:

<blockquote>
<b>29.2 Header `<atomic>` synopsis <span style="float: right;">[atomics.syn]</span></b>

<pre><code>
namespace std {
  <i>// ...</i>
  
  <i>// 29.8, non-member functions</i>
  <i>// ...</i>

</code></pre>
<pre class="ins"><code>  template&lt;class T&gt; </code></pre>
<pre class="ins"><code>    void atomic_notify_one(const volatile atomic&lt;T&gt;*);</code></pre>
<pre class="ins"><code>  template&lt;class T&gt; </code></pre>
<pre class="ins"><code>    void atomic_notify_one(const atomic&lt;T&gt;*);</code></pre>
<pre class="ins"><code>  void atomic_notify_one(const volatile atomic_flag*);</code></pre>
<pre class="ins"><code>  void atomic_notify_one(const atomic_flag*);</code></pre>
<pre class="ins"><code>  template&lt;class T&gt; </code></pre>
<pre class="ins"><code>    void atomic_notify_all(const volatile atomic&lt;T&gt;*);</code></pre>
<pre class="ins"><code>  template&lt;class T&gt; </code></pre>
<pre class="ins"><code>    void atomic_notify_all(const atomic&lt;T&gt;*);</code></pre>
<pre class="ins"><code>  void atomic_notify_all(const volatile atomic_flag*);</code></pre>
<pre class="ins"><code>  void atomic_notify_all(const atomic_flag*);</code></pre>
<pre class="ins"><code>  template&lt;class T&gt; </code></pre>
<pre class="ins"><code>    void atomic_wait(const volatile atomic&lt;T&gt;*, </code></pre>
<pre class="ins"><code>                     typename atomic&lt;T&gt;::value_type);</code></pre>
<pre class="ins"><code>  template&lt;class T&gt; </code></pre>
<pre class="ins"><code>    void atomic_wait(const atomic&lt;T&gt;*,</code></pre>
<pre class="ins"><code>                     typename atomic&lt;T&gt;::value_type);</code></pre>
<pre class="ins"><code>  template&lt;class T&gt; </code></pre>
<pre class="ins"><code>    void atomic_wait_explicit(const volatile atomic&lt;T&gt;*, </code></pre>
<pre class="ins"><code>                              typename atomic&lt;T&gt;::value_type, </code></pre>
<pre class="ins"><code>                              memory_order);</code></pre>
<pre class="ins"><code>  template&lt;class T&gt; </code></pre>
<pre class="ins"><code>    void atomic_wait_explicit(const atomic&lt;T&gt;*, </code></pre>
<pre class="ins"><code>                              typename atomic&lt;T&gt;::value_type,</code></pre>
<pre class="ins"><code>                              memory_order);</code></pre>
<pre></code>
&nbsp;
&nbsp; <i>// 29.3, type aliases</i>
  <i>// ...</i>
   
  using atomic_intptr_t       = atomic&lt;intptr_t&gt;;
  using atomic_uintptr_t      = atomic&lt;uintptr_t&gt;;
  using atomic_size_t         = atomic&lt;size_t&gt;;
  using atomic_ptrdiff_t      = atomic&lt;ptrdiff_t&gt;;
  using atomic_intmax_t       = atomic&lt;intmax_t&gt;;
  using atomic_uintmax_t      = atomic&lt;uintmax_t&gt;;
 
</code></pre>
<pre class="ins"><code>  using atomic_int_fast_wait_t  = atomic&lt;<i>implementation-defined</i>&gt;;</code></pre>
<pre class="ins"><code>  using atomic_uint_fast_wait_t = atomic&lt;<i>implementation-defined</i>&gt;;</code></pre>
<pre class="ins"><code></code></pre>
<pre class="ins"><code>  using atomic_signed_lock_free   = <i>see below</i>;</code></pre>
<pre class="ins"><code>  using atomic_unsigned_lock_free = <i>see below</i>;</code></pre>
<pre><code>
&nbsp;
  <i>// ...</i>

  <i>// 29.8, flag type and operations</i>
  struct atomic_flag;
</code></pre>
<ins><xmp>
  bool atomic_flag_test(volatile atomic_flag*) noexcept;
  bool atomic_flag_test(atomic_flag*) noexcept;
  bool atomic_flag_test_explicit(volatile atomic_flag*, memory_order) noexcept;
  bool atomic_flag_test_explicit(atomic_flag*, memory_order) noexcept;
</xmp></ins>
<pre><code>
&nbsp; bool atomic_flag_test_and_set(volatile atomic_flag*) noexcept;
  bool atomic_flag_test_and_set(atomic_flag*) noexcept;
  bool atomic_flag_test_and_set_explicit(volatile atomic_flag*, memory_order) noexcept;
  bool atomic_flag_test_and_set_explicit(atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear(volatile atomic_flag*) noexcept;
  void atomic_flag_clear(atomic_flag*) noexcept;
  void atomic_flag_clear_explicit(volatile atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear_explicit(atomic_flag*, memory_order) noexcept;
</code></pre>
<pre class="ins"><code>  void atomic_flag_wait(const volatile atomic_flag*, bool) noexcept;</code></pre>
<pre class="ins"><code>  void atomic_flag_wait(const atomic_flag*, bool) noexcept;</code></pre>
<pre class="ins"><code>  void atomic_flag_wait_explicit(const volatile atomic_flag*, bool, memory_order) noexcept;</code></pre>
<pre class="ins"><code>  void atomic_flag_wait_explicit(const atomic_flag*, bool, memory_order) noexcept;</code></pre>
<pre class="ins"><code>  void atomic_flag_notify_one(volatile atomic_flag*) noexcept;</code></pre>
<pre class="ins"><code>  void atomic_flag_notify_one(atomic_flag*) noexcept;</code></pre>
<pre class="ins"><code>  void atomic_flag_notify_all(volatile atomic_flag*) const noexcept;</code></pre>
<pre class="ins"><code>  void atomic_flag_notify_all(atomic_flag*) const noexcept;</code></pre>
<pre><code>
&nbsp; #define ATOMIC_FLAG_INIT <i>see below</i>

  <i>// 29.9, fences</i>
  extern "C" void atomic_thread_fence(memory_order) noexcept;
  extern "C" void atomic_signal_fence(memory_order) noexcept;
}
</code></pre>
</blockquote>

Modify <a href="http://eel.is/c++draft/atomics.alias">[**atomics.alias**]</a> as follows:

<blockquote>
<b>29.3 Type aliases <span style="float: right;">[atomics.alias]</span></b>

<div class="numbered">
The type aliases `atomic_intN_t`, `atomic_uintN_t`, `atomic_intptr_t`, and `atomic_uintptr_t` are defined if and only if `intN_t`, `uintN_t`, `intptr_t`, and `uintptr_t` are defined, respectively.
</div>

<div class="ins">
<div class="numbered">
The type aliases `atomic_signed_lock_free` and `atomic_unsigned_lock_free` are defined to be specializations of `atomic` whose template arguments are integral types, respectively signed and unsigned, other than `bool`.
In <a href="http://eel.is/c++draft/intro.compliance#def:freestanding_implementation">freestanding implementations</a> (4.1), these aliases are optional. If an implementation provides a integral specialization of `atomic` other than `bool` for which `is_always_lock_free` is true, it shall define `atomic_signed_lock_free` and `atomic_unsigned_lock_free`. Otherwise, they shall not be defined.
`is_always_lock_free` shall be `true` for `atomic_signed_lock_free` and `atomic_unsigned_lock_free`.
An implementation which defines these type aliases should choose the integral specialization of `atomic` for which the [=atomic waiting and notifying operations=] are most efficient.
</div>

<div class="numbered">
The type aliases `atomic_int_fast_wait_t` and `atomic_uint_fast_wait_t` are integral atomic types.
Implementations should ensure that invocations of [=atomic waiting and notifying operations=] (29.�) with these types have the lowest performance overhead among integer types.
</div>
</div>
</blockquote>

Note: The reference to "[=atomic waiting and notifying operations=]" in the above change should refer to the new <a href="http://eel.is/c++draft/atomic.wait">[**atomic.wait**]</a> subclause.

Add a new subclause after <a href="http://eel.is/c++draft/atomics.lockfree">[**atomics.lockfree**]</a>:

<blockquote class="ins">
<b>29.� Waiting and notifying <span style="float: right;">[atomics.wait]</span></b>

<div class="numbered">
<dfn>Atomic waiting and notifying operations</dfn> provide a mechanism to wait for the value of an atomic object to change more efficiently than can be achieved with polling.
</div>

<div class="numbered">
The following functions are <dfn>atomic waiting operations</dfn>:

  - `atomic<T>::wait`.
  - `atomic_flag::wait`.
  - `atomic_wait` and `atomic_wait_explicit`.

</div>

<div class="numbered">
The following functions are <dfn>atomic notifying operations</dfn>:

  - `atomic<T>::notify_one` and `atomic<T>::notify_all`.
  - `atomic_flag::notify_one` and `atomic_flag::notify_all`.
  - `atomic_notify_one` and `atomic_notify_one_explicit`.
  - `atomic_flag_notify_one` and `atomic_flag_notify_one_explicit`.
  - `atomic_notify_all` and `atomic_notify_all_explicit`.
  - `atomic_flag_notify_all` and `atomic_flag_notify_all_explicit`.

</div>

<div class="numbered">
[=Atomic waiting operations=] in this facility may block until they are unblocked by [=atomic notifying operations=], according to each function’s effects.
[ *Note:* Programs are not guaranteed to observe transient atomic values, an issue known as the A-B-A problem, resulting in continued blocking if a condition is only temporarily met. – *end note* ]
</div>
</blockquote>

Modify <a href="http://eel.is/c++draft/atomics.types.generic">[**atomics.types.generic**]</a> as follows:

<blockquote>
<b>29.7 Class template `atomic` <span style="float: right;">[atomics.type.generic]</span></b>

<pre><code>
namespace std {
  template&lt;class T&gt; struct atomic {
    using value_type = T;
    static constexpr bool is_always_lock_free = implementation-defined;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(T, memory_order = memory_order::seq_cst) volatile noexcept;
    void store(T, memory_order = memory_order::seq_cst) noexcept;
    T load(memory_order = memory_order::seq_cst) const volatile noexcept;
    T load(memory_order = memory_order::seq_cst) const noexcept;
    operator T() const volatile noexcept;
    operator T() const noexcept;
    T exchange(T, memory_order = memory_order::seq_cst) volatile noexcept;
    T exchange(T, memory_order = memory_order::seq_cst) noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order, memory_order) noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order, memory_order) noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order = memory_order::seq_cst) volatile noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order = memory_order::seq_cst) noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order = memory_order::seq_cst) volatile noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order = memory_order::seq_cst) noexcept;
</code></pre>
<pre class="ins"><code>    void wait(T old, memory_order = memory_order::seq_cst) const volatile noexcept;</code></pre>
<pre class="ins"><code>    void wait(T old, memory_order = memory_order::seq_cst) const noexcept;</code></pre>
<pre class="ins"><code>    void notify_one() const volatile noexcept;</code></pre>
<pre class="ins"><code>    void notify_one() const noexcept;</code></pre>
<pre class="ins"><code>    void notify_all() const volatile noexcept;</code></pre>
<pre class="ins"><code>    void notify_all() const noexcept;</code></pre>
<pre><code>
&nbsp;   atomic() noexcept = default;
    constexpr atomic(T) noexcept;
    atomic(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) volatile = delete;
    T operator=(T) volatile noexcept;
    T operator=(T) noexcept;
  };
}
</code></pre>
</blockquote>

Add the following to the end of <a href="http://eel.is/c++draft/atomics.types.operations">[**atomics.types.operations**]</a>:

<blockquote class="ins">
```
void wait(T old, memory_order order = memory_order::seq_cst) const volatile noexcept;
void wait(T old, memory_order order = memory_order::seq_cst) const noexcept;
```

<div class="numbered">
*Requires:* The `order` argument shall not be `memory_order_release` nor `memory_order_acq_rel`.
</div>

<div class="numbered">
*Effects:* Repeatedly performs the following steps, in order: 

  - Evaluates `object->load(order) != old` then, if the result is `true`, returns.
  - Blocks until an implementation-defined condition has been met.
    [ *Note:* Consequently, it may unblock for reasons other than an [=atomic notifying operation=]. — *end note* ]

</div>

<div class="numbered">
*Remarks:* This function is an [=atomic waiting operation=].
</div>

```
void notify_one() const volatile noexcept;
void notify_one() const noexcept;
```

<div class="numbered">
*Effects:* Unblocks up to execution of an [=atomic waiting operation=] that blocked after observing the result of an atomic operation `X`, if there exists another atomic operation `Y`, such that `X` precedes `Y` in the modification order of `*this`, and `Y` happens before this call.
</div>

<div class="numbered">
*Remarks:* This function is an [=atomic notifying operation=].
</div>

```
void notify_all() const volatile noexcept;
void notify_all() const noexcept;
```

<div class="numbered">
*Effects:* Unblocks each execution of an [=atomic waiting operation=] that blocked after observing the result of an atomic operation `X`, if there exists another atomic operation `Y`, such that `X` precedes `Y` in the modification order of `*this`, and `Y` happens before this call.
</div>

<div class="numbered">
*Remarks:* This function is an [=atomic notifying operation=].
</div>

</blockquote>

Modify <a href="http://eel.is/c++draft/atomics.flag">[**atomics.flag**]</a> as follows:

<blockquote>
<b>29.8 Flag type and operations <span style="float: right;">[atomics.flag]</span></b>

<xmp>
namespace std {
  struct atomic_flag {
</xmp>
<ins><xmp>
    bool test(memory_order = memory_order_seq_cst) volatile noexcept;
    bool test(memory_order = memory_order_seq_cst) noexcept;
</xmp></ins>
<pre><code>
&nbsp;   bool test_and_set(memory_order = memory_order_seq_cst) volatile noexcept;
    bool test_and_set(memory_order = memory_order_seq_cst) noexcept;
    void clear(memory_order = memory_order_seq_cst) volatile noexcept;
    void clear(memory_order = memory_order_seq_cst) noexcept;
</code></pre>
<pre class="ins"><code>    void wait(bool, memory_order = memory_order::seq_cst) const volatile noexcept;</code></pre>
<pre class="ins"><code>    void wait(bool, memory_order = memory_order::seq_cst) const noexcept;</code></pre>
<pre class="ins"><code>    void notify_one() const volatile noexcept;</code></pre>
<pre class="ins"><code>    void notify_one() const noexcept;</code></pre>
<pre class="ins"><code>    void notify_all() const volatile noexcept;</code></pre>
<pre class="ins"><code>    void notify_all() const noexcept;</code></pre>
<pre><code>
&nbsp;
&nbsp;   atomic_flag() noexcept = default;
    atomic_flag(const atomic_flag&amp;) = delete;
    atomic_flag&amp; operator=(const atomic_flag&amp;) = delete;
    atomic_flag&amp; operator=(const atomic_flag&amp;) volatile = delete;
  };
 
</code></pre>
<ins><xmp>
  bool atomic_flag_test(volatile atomic_flag*) noexcept;
  bool atomic_flag_test(atomic_flag*) noexcept;
  bool atomic_flag_test_explicit(volatile atomic_flag*, memory_order) noexcept;
  bool atomic_flag_test_explicit(atomic_flag*, memory_order) noexcept;
</xmp></ins>
<pre><code>
&nbsp; bool atomic_flag_test_and_set(volatile atomic_flag*) noexcept;
  bool atomic_flag_test_and_set(atomic_flag*) noexcept;
  bool atomic_flag_test_and_set_explicit(volatile atomic_flag*, memory_order) noexcept;
  bool atomic_flag_test_and_set_explicit(atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear(volatile atomic_flag*) noexcept;
  void atomic_flag_clear(atomic_flag*) noexcept;
  void atomic_flag_clear_explicit(volatile atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear_explicit(atomic_flag*, memory_order) noexcept;
</code></pre>
<ins><xmp>
  void atomic_flag_wait(const volatile atomic_flag*, bool) noexcept;
  void atomic_flag_wait(const atomic_flag*, bool) noexcept;
  void atomic_flag_wait_explicit(const volatile atomic_flag*, bool, memory_order) noexcept;
  void atomic_flag_wait_explicit(const atomic_flag*, bool, memory_order) noexcept;
  void atomic_flag_notify_one(volatile atomic_flag*) noexcept;
  void atomic_flag_notify_one(atomic_flag*) noexcept;
  void atomic_flag_notify_all(volatile atomic_flag*) const noexcept;
  void atomic_flag_notify_all(atomic_flag*) const noexcept;
</xmp></ins>
<pre><code>
&nbsp;
&nbsp; #define ATOMIC_FLAG_INIT <i>see below</i>
</code></pre>
<xmp>
}
</xmp>

<div class="numbered">
The `atomic_flag` type provides the classic test-and-set functionality. It has two states, set and clear.
</div>

<div class="numbered">
Operations on an object of type `atomic_flag` shall be lock-free.
[ *Note:* Hence the operations should also be address-free. — *end note* ]
</div>

<div class="numbered">
The `atomic_flag` type is a standard-layout struct. It has a trivial default
constructor and a trivial destructor.
</div>

<div class="numbered">
The macro `ATOMIC_FLAG_INIT` shall be defined in such a way that it can be used to initialize an object of type `atomic_flag` to the clear state.
The macro can be used in the form:

<xmp>atomic_flag guard = ATOMIC_FLAG_INIT;</xmp>

It is unspecified whether the macro can be used in other initialization contexts.
For a complete static-duration object, that initialization shall be static.
Unless initialized with `ATOMIC_FLAG_INIT`, it is unspecified whether an `atomic_flag` object has an initial state of set or clear.
</div>

<div class="ins">
<xmp>
   bool atomic_flag_test(volatile atomic_flag* object) noexcept;
   bool atomic_flag_test(atomic_flag* object) noexcept;
   bool atomic_flag_test_explicit(volatile atomic_flag* object, memory_order order) noexcept;
   bool atomic_flag_test_explicit(atomic_flag* object, memory_order order) noexcept;
   bool atomic_flag::test(memory_order order = memory_order_seq_cst) volatile noexcept;
   bool atomic_flag::test(memory_order order = memory_order_seq_cst) noexcept;
</xmp>

<div class="newnumbered">
*Requires:* The `order` argument shall not be `memory_order_release` nor `memory_order_acq_rel`.
</div>

<div class="newnumbered">
*Effects:* Memory is affected according to the value of `order`.
</div>

<div class="newnumbered">
*Returns:* Atomically returns the value pointed to by `object` or `this`.
</div>
</div>

<xmp>
   bool atomic_flag_test_and_set(volatile atomic_flag* object) noexcept;
   bool atomic_flag_test_and_set(atomic_flag* object) noexcept;
   bool atomic_flag_test_and_set_explicit(volatile atomic_flag* object,
                                          memory_order order) noexcept;
   bool atomic_flag_test_and_set_explicit(atomic_flag* object, memory_order order) noexcept;
   bool atomic_flag::test_and_set(memory_order order = memory_order_seq_cst) volatile noexcept;
   bool atomic_flag::test_and_set(memory_order order = memory_order_seq_cst) noexcept;
</xmp>

<div class="numbered">
*Effects:* Atomically sets the value pointed to by `object` or by `this` to `true`.
Memory is affected according to the value of `order`.
These operations are atomic read-modify-write operations (4.7).
</div>

<div class="numbered">
*Returns:* Atomically, the value of the object immediately before the effects.
</div>

<xmp>
void atomic_flag_clear(volatile atomic_flag* object) noexcept;
void atomic_flag_clear(atomic_flag* object) noexcept;
void atomic_flag_clear_explicit(volatile atomic_flag* object,
                                memory_order order) noexcept;
void atomic_flag_clear_explicit(atomic_flag* object, memory_order order) noexcept;
void atomic_flag::clear(memory_order order = memory_order_seq_cst) volatile noexcept;
void atomic_flag::clear(memory_order order = memory_order_seq_cst) noexcept;
</xmp>

*Requires:* The `order` argument shall not be `memory_order_consume`,
`memory_order_acquire`, nor `memory_order_acq_rel`.

*Effects:* Atomically sets the value pointed to by `object` or by `this` to
`false`. Memory is affected according to the value of `order`.

<div class="ins">
<xmp>
void atomic_flag_wait(const volatile atomic_flag* object, bool old) noexcept;
void atomic_flag_wait(const atomic_flag* object, bool old) noexcept;
void atomic_flag_wait_explicit(const volatile atomic_flag* object,
                               bool old, memory_order order) noexcept;
void atomic_flag_wait_explicit(const atomic_flag* object,
                               bool old, memory_order order) noexcept;
void atomic_flag::wait(bool old,
                       memory_order order = memory_order::seq_cst) const volatile noexcept;
void atomic_flag::wait(bool old,
                       memory_order order = memory_order::seq_cst) const noexcept;
</xmp>

<div class="numbered">
*Requires:* The `order` argument shall not be `memory_order_release` nor `memory_order_acq_rel`.
</div>

<div class="numbered">
*Effects:* Repeatedly performs the following steps, in order: 

  - Evaluates `object->load(order) != old` then, if the result is `true`, returns.
  - Blocks until an implementation-defined condition has been met.
    [ *Note:* Consequently, it may unblock for reasons other than an [=atomic notifying operation=]. — *end note* ]

</div>

<div class="numbered">
*Remarks:* This function is an [=atomic waiting operation=].
</div>

<xmp>
void atomic_flag_notify_one(volatile atomic_flag* object) noexcept;
void atomic_flag_notify_one(atomic_flag* object) noexcept;
void atomic_flag::notify_one() const volatile noexcept;
void atomic_flag::notify_one() const noexcept;
</xmp>

<div class="numbered">
*Effects:* Unblocks up to one execution of a [=atomic waiting operation=] that blocked after observing the result of an atomic operation `X`, if there exists another atomic operation `Y`, such that `X` precedes `Y` in the modification order of `*object` or `*this`, and `Y` happens before this call.
</div>

<div class="numbered">
*Remarks:* This function is an [=atomic notifying operation=].
</div>

<xmp>
void atomic_flag_notify_all(volatile atomic_flag* object) const noexcept;
void atomic_flag_notify_all(atomic_flag* object) const noexcept;
void atomic_flag::notify_all() const volatile noexcept;
void atomic_flag::notify_all() const noexcept;
</xmp>

<div class="numbered">
*Effects:* Unblocks each execution of a [=atomic waiting operation=] that blocked after observing the result of an atomic operation `X`, if there exists another atomic operation `Y`, such that `X` precedes `Y` in the modification order of `*object` or `*this`, and `Y` happens before this call.
</div>

<div class="numbered">
*Remarks:* This function is an [=atomic notifying operation=].
</div>

</div>
</blockquote>

Modify Table 135 "Thread support library summary" in <a href="http://eel.is/c++draft/thread.general">[**thread.general**]</a> as follows:

<blockquote>
<div style="text-align: center;">
Table 135 — Thread support library summary
</div>
<table border=1 style="margin: auto;">
<tr>             <th></th>     <th>Subclause</th>            <th>Header(s)</th> </tr>
<tr>             <td>30.2</td> <td>Requirements</td>         <td></td> </tr>
<tr>             <td>30.3</td> <td>Threads</td>              <td>`<thread>`</td> </tr>
<tr>             <td>30.4</td> <td>Mutual exclusion</td>     <td>`<mutex>` `<shared_mutex>`</td> </tr>
<tr>             <td>30.5</td> <td>Condition variables</td>  <td>`<condition_variable>`</td> </tr>
<tr class="ins"> <td>30.�</td> <td>Semaphores</td>           <td>`<semaphore>`</td> </tr>
<tr class="ins"> <td>30.�</td> <td>Latches and barriers</td> <td>`<latch>` `<barrier>`</td> </tr>
<tr>             <td>30.6</td> <td>Futures</td>              <td>`<future>`</td> </tr>
</table>
</blockquote>

Add two new subclauses after <a href="http://eel.is/c++draft/thread.condition">[**thread.condition**]</a>:

<blockquote class="ins">
<b>30.� Semaphores <span style="float: right;">[thread.semaphore]</span></b>

<div class="numbered">
Semaphores are lightweight synchronization primitives used to constrain concurrent access to a shared resource. They are widely used to implement other synchronization primitives and, whenever both are applicable, can be more efficient than condition variables.
</div>

<div class="numbered">
A counting semaphore is a semaphore object that models a non-negative resource count. A binary semaphore is a semaphore object that has only two states, also known as available and unavailable.
[ *Note:* A binary semaphore should be more efficient than a counting semaphore with a unit magnitude count. – *end note* ]
</div>
</blockquote>

<blockquote class="ins">
<b>30.�.1 Header `<semaphore>` synopsis <span style="float: right;">[thread.semaphore.syn]</span></b>

<pre><code>
namespace std {  
  template&lt;ptrdiff_t least_max_value = <i>implementation-defined</i>&gt;
    class counting_semaphore;

  using binary_semaphore = counting_semaphore&lt;1&gt;;
}
</code></pre>
</blockquote>

<blockquote class="ins">
<b>30.�.2 Class template `counting_semaphore` <span style="float: right;">[thread.semaphore.counting.class]</span></b>

<pre><code>
namespace std {
  template&lt;ptrdiff_t least_max_value&gt;
  class counting_semaphore {
  public:
    static constexpr ptrdiff_t max() noexcept;

    explicit counting_semaphore(ptrdiff_t);
    ~counting_semaphore();

    counting_semaphore(const basic_semaphore&amp;) = delete;
    counting_semaphore(basic_semaphore&amp;&amp;) = delete;
    counting_semaphore&amp; operator=(const basic_semaphore&amp;) = delete;
    counting_semaphore&amp; operator=(basic_semaphore&amp;&amp;) = delete;

    void release(ptrdiff_t update = 1);
    void acquire() noexcept;
    bool try_acquire() noexcept;
    template&lt;class Clock, class Duration&gt;
      bool try_acquire_until(const chrono::time_point&lt;Clock, Duration&gt;&amp;);
    template&lt;class Rep, class Period&gt;
      bool try_acquire_for(const chrono::duration&lt;Rep, Period&gt;&amp;);

  private:
    ptrdiff_t counter; <i>// exposition only</i>
  };
}
</code></pre>

<div class="numbered">
Class `counting_semaphore` maintains an internal counter that is initialized when the semaphore is created. Threads may block waiting until `counter >= 1`.
</div>

<div class="numbered">
Semaphores permit concurrent invocation of the `release`, `acquire`, `try_acquire`, `try_acquire_for`, and `try_acquire_until` member functions.
</div>

```
static constexpr ptrdiff_t max() noexcept;
```

<div class="numbered">
*Returns:* The maximum value of `counter`. This value shall not be less than that of the template argument `least_max_value`.
[ *Note:* The value may exceed least_max_value. – *end note* ]
</div>

```
explicit counting_semaphore(ptrdiff_t desired);
```

<div class="numbered">
*Requires:* `desired >= 0` and `desired <= max()`.
</div>

<div class="numbered">
*Effects:* `counter = desired`.
</div>

<!-- Based on std::thread::thread wording -->
<div class="numbered">
*Throws:* `system_error` if unable to create the semaphore.
</div>

```
~counting_semaphore();
```

<div class="numbered">
*Requires:* For every function call that blocks on `counter`, a function call that will cause it to unblock and return shall happen before this call.
[ *Note:* This relaxes the usual rules, which would have required all wait calls to happen before destruction. — *end note* ]
</div>

<div class="numbered">
*Effects:* Destroys the object.
</div>

<div class="numbered">
*Throws:* Nothing.
</div>

``` 
void release(ptrdiff_t update = 1);
```

<div class="numbered">
*Requires:* `update >= 0`, and `counter + update <= max()`. 
</div>

<div class="numbered">
*Effects:* `counter += update`, executed atomically. If any threads are blocked on counter, unblocks them.
</div>

<div class="numbered">
*Throws:* Nothing.
</div>

<div class="numbered">
*Synchronization:* Strongly happens before invocations of `try_acquire` that observe the result of the effects.
</div>

```
bool try_acquire() noexcept;
```

<div class="numbered">
*Effects:*

  - With low probability, returns immediately. [ *Note:* An implementation should ensure that `try_acquire` does not consistently return `false` in the absence of contending acquisitions. — *end note* ] 
  - Otherwise, if `counter >= 1`, then `counter -= 1` is executed atomically.

</div>

<div class="numbered">
*Returns:* `true` if `counter` was decremented, otherwise `false`.
</div>

```
void acquire() noexcept;
```

<div class="numbered">
*Effects:* Repeatedly performs the following steps, in order:

  - Evaluates `try_acquire`, then, if the result is `true`, returns. 
  - Blocks until `counter >= 1`.

</div>

```
template<class Clock, class Duration>
  bool try_acquire_until(const chrono::time_point<Clock, Duration>& abs_time);
template<class Rep, class Period>
  bool try_acquire_for(const chrono::duration<Rep, Period>& rel_time);
```

<div class="numbered">
*Effects:* Repeatedly performs the following steps, in order:

  - Evaluates `try_acquire`. If the result is `true`, returns `true`. 
  - Blocks until the timeout expires or `counter >= 1`. If the timeout expired, returns `false`.

</div>

<div class="numbered">
*Throws:* Timeout-related exceptions (30.2.4).
</div>
</blockquote>


<blockquote class="ins">
<b>30.� Coordination Types <span style="float: right;">[thread.coord]</span></b>

<div class="numbered">
This section describes various concepts related to thread coordination, and defines the <dfn>coordination types</dfn> `latch` and `barrier`. These types facilitate concurrent computation performed by a number of threads, in one or more <dfn>phases</dfn>.
</div>

<div class="numbered">
In this subclause, a synchronization point represents a condition that a thread may contribute to or wait for, potentially blocking until it is satisfied. A thread arrives at the synchronization point when it has an effect on the state of the condition, even if it does not cause it to become satisfied.
</div>

<div class="numbered">
Concurrent invocations of the member functions of [=coordination types=], other than their destructors, do not introduce data races.
</div>
</blockquote>

<blockquote class="ins">
<b>30.�.1 Latches <span style="float: right;">[thread.coord.latch]</span></b>

<div class="numbered">
A latch is a thread coordination mechanism that allows any number of threads to block until an expected count is summed (exactly) by threads that arrived at the latch. The expected count is set when the latch is constructed. An individual latch is a single-use object; once the count has been reached, the latch cannot be reused. 
</div>
</blockquote>

<blockquote class="ins">
<b>30.�.1.1 Header `<latch>` synopsis <span style="float: right;">[thread.coord.latch.syn]</span></b>

<xmp>
namespace std {
  class latch;
}
</xmp>
</blockquote>

<blockquote class="ins">
<b>30.�.1.2 Class `latch` <span style="float: right;">[thread.coord.latch.class]</span></b>

<pre><code>
namespace std {
  class latch {
  public:
    explicit latch(ptrdiff_t expected);
    ~latch();

    latch(const latch&amp;) = delete;
    latch(latch&amp;&amp;) = delete;
    latch&amp; operator=(const latch&amp;) = delete;
    latch&amp; operator=(latch&amp;&amp;) = delete;
    
    void count_down(ptrdiff_t update = 1);
    bool try_wait() const noexcept;
    void wait() const noexcept;
    void sync(ptrdiff_t update = 1);

  private:
    ptrdiff_t counter; <i>// exposition only</i>
  };
} 
</code></pre>

<div class="numbered">
A `latch` maintains an internal counter that is initialized when the `latch` is created. Threads may block at the `latch`’s synchronization point, waiting for `counter` to be decremented to `0`.
</div>

```
explicit latch(ptrdiff_t expected);
```

<div class="numbered">
*Requires:* `expected >= 0`. 
</div>

<div class="numbered">
*Effects:* `counter = expected`.
</div>

<!-- Based on std::thread::thread wording -->
<div class="numbered">
*Throws:* `system_error` if unable to create the latch.
</div>

```
~latch();
```

<div class="numbered">
*Requires:* No threads are blocked at the synchronization point.
</div>

<div class="numbered">
*Effects:* Destroys the latch.
</div>

<div class="numbered">
*Throws:* Nothing.
</div>

<div class="numbered">
*Remarks:* May be called even if some threads have not yet returned from functions that block at the synchronization point, provided that they are unblocked. [ *Note:* The destructor may block until all threads have exited invocations of `wait` on this object. — *end note* ]
</div>


```
void count_down(ptrdiff_t update = 1);
```

<div class="numbered">
*Requires:* `counter >= update` and `update >= 0`.
</div>

<div class="numbered">
*Effects:* Atomically decrements `counter` by `update`.
</div>

<div class="numbered">
*Throws:* Nothing.
</div>

<div class="numbered">
*Synchronization:* Synchronizes with the returns from all calls unblocked by the effects.
</div>

<div class="numbered">
*Remarks:* Arrives at the synchronization point with `update` count.
</div>

```
bool try_wait() const noexcept;
```

<div class="numbered">
*Returns:* `counter == 0`. 
</div>


```
void wait() const noexcept;
```

<div class="numbered">
*Effects:* If `counter == 0`, returns immediately. Otherwise, blocks the calling thread at the synchronization point until `counter == 0`. 
</div>

```
void sync(ptrdiff_t update = 1);
```

<div class="numbered">
*Effects:* Equivalent to `count_down(update); wait();`.
</div>

<div class="numbered">
*Throws:* Nothing.
</div>
</blockquote>

<blockquote class="ins">
<b>30.�.2 Barriers <span style="float: right;">[thread.coord.barrier]</span></b>

<div class="numbered">
A barrier is a thread coordination mechanism that allows at most an expected count of threads to block until that count is summed (exactly) by threads that arrived at the barrier in each of its successive [=phases=]. Once threads are released from blocking at the synchronization point for a [=phase=], they can reuse the same barrier immediately in its next [=phase=]. [ *Note:* It is thus useful for managing repeated tasks, or [=phases=] of a larger task, that are handled by multiple threads. — *end note* ]
</div>

<div class="numbered">
A barrier has a <dfn>completion step</dfn> that is a (possibly empty) set of effects associated with a [=phase=] of the barrier. When the member functions defined in this subclause arrive at the barrier, they have the following effects: 

  - When the expected number of threads for this [=phase=] have arrived at the barrier, one of those threads executes the barrier type's [=completion step=]. 
  - When the [=completion step=] is completed, all threads blocked at the synchronization point for this [=phase=] are unblocked and the barrier enters its next [=phase=]. The end of the [=completion step=] strongly happens before the returns from all calls unblocked by its completion.

</div>
</blockquote>

<blockquote class="ins">
<b>30.�.2.1 Header `<barrier>` synopsis <span style="float: right;">[thread.coord.barrier.syn]</span></b>

<pre><code>
namespace std {
  template&lt;class CompletionFunction = <i>implementation-defined</i>&gt;
    class barrier;
}
</code></pre>
</blockquote>

<blockquote class="ins">
<b>30.�.2.2 Class template `barrier` <span style="float: right;">[thread.coord.barrier.class]</span></b>

<pre><code>
namespace std {
  template&ltclass CompletionFunction&gt;
  class barrier {
  public:
    using arrival_token = implementation-defined;

    explicit barrier(ptrdiff_t expected,
                     CompletionFunction f = CompletionFunction());
    ~barrier();

    barrier(const barrier&amp;) = delete;
    barrier(barrier&amp;&amp;) = delete;
    barrier&amp; operator=(const barrier&amp;) = delete;
    barrier&amp; operator=(barrier&amp;&amp;) = delete;

    [[nodiscard]] arrival_token arrive(ptrdiff_t update = 1);
    void wait(arrival_token&& arrival) const;

    void sync();
    void arrive_and_drop();

  private:
    CompletionFunction completion; <i>// exposition only</i>
  };
}
</code></pre>

<div class="numbered">
A `barrier` is a barrier type with a [=completion step=] controlled by a function object. The [=completion step=] calls `completion`. Threads may block at the barrier's synchronization point for a [=phase=], waiting for the expected sum contributions by threads that arrive in that [=phase=].
</div>

<div class="numbered">
`CompletionFunction` shall be `CopyConstructible`, `is_invocable_r_v<void, CompletionFunction>` shall be `true`, and `noexcept(declval<CompletionFunction>()())` shall be `true`.
</div>

<div class="numbered">
`barrier::arrival_token` is an implementation-defined type. `is_nothrow_move_constructible_v<barrier::arrival_token>` shall be `true` and  `is_nothrow_move_assignable_v<barrier::arrival_token>` shall be `true`.
</div>

```
explicit barrier(ptrdiff_t expected, CompletionFunction f);
```

<div class="numbered">
*Requires:* `expected >= 0`, and `noexcept(f())` shall be `true`.
</div>


<div class="numbered">
*Effects:* Initializes the barrier for `expected` number of threads in the first [=phase=], and initializes `completion` with `move(f)`. [ *Note:* If `expected` is `0` this object may only be destroyed. — *end note* ]
</div>

<!-- Based on std::thread::thread wording -->
<div class="numbered">
*Throws:* `system_error` if unable to create the barrier.
</div>

```
~barrier();
```

<div class="numbered">
*Requires:* No threads are blocked at a synchronization point for any [=phase=].
</div>

<div class="numbered">
*Effects:* Destroys the barrier.
</div>

<div class="numbered">
*Throws:* Nothing.
</div>

<div class="numbered">
*Remarks:* May be called even if some threads have not yet returned from functions that block at a synchronization point, provided that they have unblocked. [ *Note:* The destructor may block until all threads have exited invocations of wait() on this object. — *end note* ] 
</div>

```
[[nodiscard]] arrival_token arrive(ptrdiff_t update = 1);
```

<div class="numbered">
*Requires:* The expected count is not less than `update`. 
</div>

<div class="numbered">
*Effects:* Constructs an object of type `arrival_token` that is associated with the `barrier`'s synchronization point for the current [=phase=], then arrives `update` times at the synchronization point for the current [=phase=].
</div>

<div class="numbered">
*Synchronization:* The call to `arrive` strongly happens before the start of the [=completion step=] for the current [=phase=].
</div>

<div class="numbered">
*Returns:* The constructed object.
</div>

<div class="numbered">
*Remarks:* This may cause the [=completion step=] to start.
</div>


```
void wait(arrival_token&& arrival) const;
```

<div class="numbered">
*Requires:* `arrival` is associated with a synchronization point for the current or the immediately preceding [=phases=] of the `barrier`.
</div>

<div class="numbered">
*Effects:* Blocks at the synchronization point associated with `std::move(arrival)` until the condition is satisfied.
</div>

<div class="numbered">
*Throws:* Nothing.
</div>

```
void sync();
```

<div class="numbered">
*Effects:* Equivalent to `wait(arrive())`.
</div>

<div class="numbered">
*Throws:* Nothing.
</div>

``` 
void arrive_and_drop();
```

<div class="numbered">
*Requires:* The expected number of threads for the current [=phase=] is not `0`. 
</div>

<div class="numbered">
*Effects:* Decrements the expected number of threads for subsequent [=phases=] by `1`, then arrives at the synchronization point for the current [=phase=].
</div>

<div class="numbered">
*Throws:* Nothing.
</div>

<div class="numbered">
*Synchronization:* The call to `arrive_and_drop` strongly happens before the start of the [=completion step=] for the current [=phase=].
</div>

<div class="numbered">
*Remarks:* This may cause the [=completion step=] to start.
</div>
</blockquote>

Create the following feature test macros:

  - `__cpp_lib_atomic_lock_free_type_aliases`, which implies that `atomic_signed_lock_free` and `atomic_unsigned_lock_free` types are available.
  - `__cpp_lib_atomic_flag_test`, which implies the `test` methods and free functions for `atomic_flag` are available.
  - `__cpp_lib_atomic_wait`, which implies the `notify_*` and `wait` methods and free functions for `atomic` and `atomic_flag` and the `atomic_int_fast_wait_t` and `atomic_uint_fast_wait_t` types are available.
  - `__cpp_lib_semaphore`, which implies that `counting_semaphore` and `binary_semaphore` are available.
  - `__cpp_lib_latch`, which implies that `latch` is available.
  - `__cpp_lib_barrier`, which implies that `barrier` is available.

